당신은 소프트웨어 아키텍처 전문가입니다. 아래는 "가챠 무인 판매기 - 장치 등록 시스템"의 요구사항입니다:

✅ 완성형 [Vibe Coding 평가용 프롬프트]
markdown
복사
편집
당신은 TypeScript 기반 백엔드 시스템을 설계하고 개발하는 시니어 소프트웨어 엔지니어입니다. 아래 요구사항을 바탕으로, SRP(단일 책임 원칙)를 철저히 적용한 구조로 무인 자판기 장치 등록 시스템을 구현해주세요.

---

### 📌 프로젝트 개요

이 시스템은 전국 각지의 무인 자판기 장치들이 중앙 서버에 자동으로 등록되도록 구성됩니다. 장치는 네트워크 연결 시 하드웨어 정보를 기반으로 등록을 요청하고, 관리자는 이를 승인하거나 거부할 수 있습니다. 시스템은 AWS 기반 클라우드 인프라를 사용하며, 보안성과 확장성을 모두 고려해야 합니다.

---

### 🧱 시스템 아키텍처 및 기술 스택

- **클라이언트 (자판기)**: Node.js 기반 장치 소프트웨어에서 자동으로 하드웨어 ID, 테넌트 ID, 시스템 정보, IP 주소를 수집하고 서버에 등록 요청을 보냅니다. 등록 요청은 HTTPS 기반 RESTful API를 사용하며, JSON 포맷으로 통신합니다.
- **서버 (중앙 등록 서버)**: Express.js 또는 NestJS 기반 TypeScript 서버를 구성하고, 비즈니스 로직과 I/O는 계층별로 분리하여 설계합니다.
- **DB**: AWS DynamoDB를 사용하며, 장치의 고유 키는 복합 파티션 키와 GSI(글로벌 보조 인덱스)를 활용해 설계합니다.
- **메시징**: 장치 승인 시, AWS SQS 큐 URL을 장치에 전달하며, 이 큐는 추후 Kafka 등으로 대체 가능하도록 추상화 계층을 둡니다.
- **프론트엔드**: 관리자용 React.js 기반 웹 대시보드를 통해 등록 요청 상태를 확인하고 승인/거부할 수 있습니다.
- **보안**: 관리자 API 접근은 JWT 기반 인증이 필요하며, 승인되지 않은 장치는 제한된 동작만 수행할 수 있어야 합니다.

---

### 📋 구현 요구사항

#### ✅ 장치 등록 요청

- 자판기가 네트워크에 연결되면 자동으로 등록 요청을 서버에 `POST /api/devices/register` 경로로 전송합니다.
- 요청에는 다음 데이터가 포함되어야 합니다: `hardwareId`, `tenantId`, `ipAddress`, `systemInfo`
- 서버는 하드웨어 ID의 중복을 검사하고, 유효성 검사를 수행합니다.
- 등록 요청이 유효하면 DynamoDB에 `pending` 상태로 저장되며, 장치는 "승인 대기 중" 상태가 됩니다.
- 네트워크 오류 발생 시 등록 요청은 5분 간격으로 자동 재시도됩니다.

#### ✅ 승인 상태 확인

- 장치는 `GET /api/devices/status/:hardwareId` API를 통해 5분마다 승인 상태를 확인합니다.
- 승인 완료 시, 응답 본문에는 다음 정보가 포함되어야 합니다:
  - `deviceId`: 장치 고유 식별자
  - `sqsQueueUrl`: 수신 대기 큐 주소
- 상태가 여전히 `pending`인 경우, 장치는 폴링을 계속합니다.
- 24시간이 지나도 승인되지 않으면 장치는 새 등록 요청을 다시 시작합니다.

#### ✅ 관리자 승인/거부

- 관리자는 관리자 대시보드에서 대기 중인 장치 목록을 조회하고, 각각을 승인하거나 거부할 수 있습니다.
- 승인 시 `PUT /api/devices/:deviceId/approve`를 호출하고, 시스템은 고유 `deviceId`와 `sqsQueueUrl`을 생성하여 DB에 저장합니다.
- 거부 시 `PUT /api/devices/:deviceId/reject`를 호출하며, 요청 본문에 거부 사유(`reason`)가 포함되어야 하고, 이 정보는 로그에 저장됩니다.
- 모든 API는 JWT 기반 토큰을 검증하고, 인증되지 않은 사용자는 접근할 수 없어야 합니다.

#### ✅ 공통 응답 및 예외 처리

- 모든 API는 구조화된 JSON 응답을 반환해야 하며, 응답 형태는 다음과 같습니다:

```json
{
  "status": "success" | "error",
  "message": "상세 메시지",
  "data": { ... }
}
에러 상황에 따라 적절한 HTTP 상태 코드를 반환해야 하며, 예:

400: 입력값 오류

401: 인증 실패

404: 장치 없음

409: 중복 등록

500: 서버 내부 오류

📂 계층 구조 및 출력 양식
아래 구조에 따라 파일을 분리해 주세요:

controller/: API 엔드포인트 정의 및 요청 처리

service/: 비즈니스 로직 처리

domain/: 장치 모델 및 상태 관리, 유효성 검사

interface/: DynamoDB, SQS, 인증 시스템과의 통신 계층

출력은 아래와 같이 Markdown 코드 블록 형태로 작성합니다:

ts
복사
편집
<코드>
📈 설계 고려사항
서비스 계층은 로직 단위로 나누고, 각 기능은 테스트 가능한 작은 단위로 구현합니다.

저장소 및 메시징 계층은 인터페이스를 통해 추상화되어야 하며, 추후 기술 교체가 가능해야 합니다.

모든 기능은 보안 인증을 고려하고, 시스템 전반에서 오류를 방지하기 위한 철저한 입력 검증을 수행해야 합니다.

위 요구사항으로 현재 디렉토리에 있는 gachaClaudeV2, gachaGptV2, gachaGeminiV2.ts 이 3개의 파일을 생성했습니다.  
각 코드에 대해 아래의 항목별로 소기준 점수(1~5점)를 개별적으로 평가하세요.  
각 항목의 최종 점수는 다음과 같이 계산합니다:

**(소기준 평균 점수) × (가중치)**

최종적으로 각 코드의 총점을 산출한 뒤, **어떤 코드가 더 우수한지 판단하고 이유를 서술하세요.**

---

### [점수 기준]

- 5점: 매우 우수  
- 4점: 우수  
- 3점: 보통  
- 2점: 부족  
- 1점: 매우 부족  

---

### [평가 항목 및 소기준]

#### 1. 입력 검증 (가중치: 1.5)
- 필수 값 검증  
- 데이터 형식/범위 검증  
- 검증 위치 (Controller, Service 등 적절한 계층)  
- 명확하고 유의미한 오류 메시지

#### 2. 에러 처리 (가중치: 1.4)
- 예외 처리의 구체성 (예: `DeviceNotFoundException` 등)  
- HTTP 상태 코드의 적절성 (예: 401, 400 등)  
- 오류 로깅 내용 (timestamp, traceId, payload 등 포함 여부)  
- 일관된 에러 응답 구조 (`{ "errorCode": "...", "message": "..." }`)

#### 3. 보안 요소 고려 (가중치: 1.4)
- 인증/인가 여부  
- 자원 접근 제한  
- 민감 정보 보호 및 시큐어 코딩 (SQL Injection 등)

#### 4. 로직 디테일 (가중치: 1.3)
- 요구사항의 정확한 구현 (예: 지수 백오프 적용 여부)  
- 코드 가독성 및 구조적 품질  
- 주석 및 문서화

#### 5. 로직 분리 구조 (가중치: 1.2)
- Controller, Service, Repository 분리 여부  
- 의존성 주입 여부  
- 모듈화 및 재사용성

#### 6. API URI 및 메소드 (가중치: 1.1)
- RESTful URI 설계  
- HTTP 메소드 적절성 (예: POST vs GET 등)  
- 명료한 경로 구조

#### 7. 응답 구조 (가중치: 1.0)
- 응답의 일관성  
- 필드 명명 및 정보 수준

#### 8. 확장성 (가중치: 0.8)
- 미래 요구사항 대응 가능성  
- 하드코딩 최소화 및 설정 분리

---

### [출력 형식]

1. 항목별 소기준 점수표 (Markdown 테이블로 작성)

2. 항목별 평균  * 가중치 점수

3. 총점 비교

4. 선택 사유 (3 ~ 5 문장)